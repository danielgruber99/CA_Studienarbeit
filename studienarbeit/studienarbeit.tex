\documentclass[a4paper,
DIV=13,
12pt,
BCOR=10mm,
department=FakIM,
%lucida,
%KeepRoman,
oneside,
parskip=half,
automark,
listof=totocnumbered,
bibliography=totocnumbered,
acronym=totocnumbered
%headsepline,
] {OTHRartcl}

\usepackage[utf8]{inputenc}
\usepackage[a4paper, margin=0cm, left=3.5cm, top=2.5cm, right=2.5cm, bottom=3.0cm]{geometry}
\usepackage[ngerman]{babel}
\usepackage[printonlyused]{acronym}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{minted}

\newcommand{\comment}[1]{}
\date{\today}
\title{Vulnerabilty eingebetteter Systeme}
\author{Gruber Daniel}
\studentid{3214109}
\documenttype{Studienarbeit}
\department{Informatik}
\startingdate{14.\,März 2022}
\closingdate{20.\,Juli 2022}

\firstadvisor{Jonas Schmidt}
%\secondadvisor{Herr Altmann}
%\externaladvisor{Dr. Klara Endlos}

%\externallogo[height=1.5cm]{firmenlogo}


%\ohead*{\date}
%\chead{}
%\ihead{\date}
%%\ohead{\date}
%\ofoot{}
%\cfoot{}
%\ifoot{Daniel Gruber}
%\ofoot*{\pagemark}% Seitenzahl in die Mitte des Fußes, auch auf plain Seiten

% Zeilenabstand auf 1.5
\usepackage[onehalfspacing]{setspace}

\begin{document}
\maketitle

\tableofcontents
\newpage

%Hier schonmal Abkürzungsberzeichnis vorbereitet. Im Text kann mit \ac{Abk} auf die Abkürzung referenziert werden. Es wird automatisch beim ersten referenzieren die volle Schreibweise genommen, ab dann immer die abkürzung
\section*{Abkürzungsverzeichnis}
\label{abkuerzungsverzeichnis}
\begin{acronym}[AUTOSAR]
  \acro{ecu}[ECU]{Electronic Control Unit}
  \acro{mpu}[MPU]{Memory Protection Unit}
  \acro{risc}[RISC]{Reduced Instruction Set Computer}
\end{acronym}
\newpage

% ============================================================================== Kapitel 1: Einleitung ===========================================================================================================
\section{Einleitung}
Die Vernetzung im Fahrzeug sowohl mit dem Internet als auch intern nimmt immer weiter zu. Die Anzahl der \acs{ecu} ist von einer kleinen unabhängigen Architektur
zu eine funktionsspezifischen und weiterhin zu einer zentralisierten Architektur gewachsen mit bis zu circa 150ECUS einem Premium Segement Fahrzeug.
Mit dem starken Anstieg von \acs{ecu} im Auto nimmt einerseits die Funktionialität für den Nutzer zu, jedoch bilden sich durch mehr Software und Funktionialität
mehr Angriffsmöglichkeiten auf das System \"Auto\" an sich. Hier ist es neben sicherem Code schreiben (Software) auch ein sehr wichtiger Aspekt
die Hardware zu kennen und insbesondere deren Schwachstellen.
In dieser Arbeit wird auf die STM32 Architektur eingegangen und anhand dieser drei typische Schwachstellen erklärt. Zudem wird zu jeder dieser
Schwachstellen Präventionsmaßnahmen beschrieben.
Abschließend wird die Skalierbarkeit einer dieser Schwachstellen in Form eines xxxxxx Angnriffes auf ein Fahrzeug aufgegriffen und darüber
eine Diskussion dargestellt, welche Maßnahmen dagegen getroffen werden können und welche Vorteile/Nachteile diese Maßnahmen haben.


% ============================================================================== Kapitel 2: Vorstellung wichtiger Rahmenbedinungen ===============================================================================
\section{Vorstellung wichtiger Rahmenbedingungen}
% Architekturmerkmale, Adressierungsmoid, Ausführungsmodelle, Betriebssstem

% Architektur des STM32F103C8T6 ARM®Cortex®-M3 32-bit RISC core, 72MHz, 64KB (64Kx8) Flash
% ARM v5 32 little endian
% Adapted Harvard Architektur: getrennte Busse für Befehle und Daten, aber beides liegt im Flash

%STM32F103C8T6	32Bit MCU, ARM CORTEX M3, Flash 64KB, RAM 20KB, IO 37, A/D 10x12b, 72MHz, LQFP48

%Die Cortex-M3-Architektur kann somit als Nachfolger für den ARM7 betrachtet werden und stellt mehr Rechenleistung als ein ARM7 bei geringerer Komplexität des Programmiermodells sowie geringerer Chipfläche zur Verfügung. Andere Untergruppen, wie z. B. der M1, sind z. B. für die Implementierung auf einem FPGA verfügbar.

Die STM32 Mikrocontroller-Familie werden vom europäischen Halbleiterhersteller STMicroelectronics N.V. produziert, welche als eine der ersten Hersteller
die CORTEX M3 Lizenz von der Firma ARM erworben hat.
Der STM32 Controller zeichnet sich durch eine 32-Bit ARM Cortex-M0/M3/M4 CPU aus, die speziell für Mikrocontroller neu entwickelt wurde.
ARM ist ein \ac*{risc}, welche den Vorteil von insbesondere einen kompakten Befehlssatz sowie vielen Registern hat.
% Load/Store Register to register loading architecture!
%Die Cortex M3 wird inoffziell als leistungsfähigerer Nachfolger der ARM7 TDMI Controller betrachtet.
%Diese ARchitektur verwendet ausschließlich den THumb2 Befehlssatz.
% RISC!
%%%% LR REGISTER
% BUFFER OVERLOW: wichtig, dass LR register da ist, da wird stack pointer gesichert und geladen, deswegen 2 funktionen um quasi return adr. zu überschreiben,
% - Stores return address in LR
% - Returning implemented by restoring the PC from LR
% - For non-leaf functions, LR will have to be stacked
Das Speichermodell bzw. der Adressierungsbereich von 4GB der CPU ist wie in der linken Abbildung dargestellt.
Teil dieses Adressierungsbereichs sind der Code, der sich im Flash befindet, und der SRAM, welche beide in der rechten Abbildung dargestellt sind.
Dabei ist insbesondere wichtig, dass der Stack nach unten, d.h. von höheren zu niedrigen Adressen wächst, was es ermöglicht,
return Adressen und andere Bereiche im SRAM über einen Buffer Overflow oder eine Format String Vulnerabilty für Angriffe auszunutzen.
\begin{figure}[ht!]
  \begin{minipage}[b]{.45\linewidth}
    \includegraphics[scale=0.47]{figures/memory_model.png}
    \caption{Memory map}
    \label{Abbildung 1: Memory map}
  \end{minipage}
  \hspace{.1\linewidth}
  \begin{minipage}[b]{.48\linewidth}
    \includegraphics[width=\linewidth]{figures/flash_sram.png}
    \caption{Flash und SRAM}
    \label{Abbildung 6: Flash und SRAM}
  \end{minipage}
\end{figure}

Auch die Funktionsweise des LR Register ist für die konkrete Ausnutzung nachfolgender Schwachstellen bedeutend.
Denn dieses speichert die Return addresse der Funktion. Erst wenn mehere Funktionen vorhanden sind wird die return Adresse auf dem Stack gespeichert und muss von
diesem wieder geladen werden. Deswegen müssen bei der Überschreibung von Return Adressen zwei Funktionen, wobei eine die andere aufruft, um die Überschreibung
der returnadresse der äußeren Funktion zu ermöglichen
\begin{figure}[ht!]
\begin{center}
  \includegraphics[scale=0.28]{figures/arm_register_set_detailled.png}
  \caption{ARM Register Set}
  \label{Abbildung 1: ARM Register Set}
\end{center}
\end{figure}

Ein Hauptbestandteil des Cortex M3 Prozessors, wie beim STM32F103C8T6 vorhanden, ist die dreistufige Pipeline, die auf der Harvard Architektur basiert.
Hierbei existieren, wie für die Harvard Architektur typisch, verschiedene Busse für Befehle und Daten, welches ermöglicht zugleich Befehle und Daten zu lesen bzw. Daten in den Speicher zurückzuschreiben.
Aus Programmierersicht ist die CPU aber ein Von-Neumann Modell, da zwar die Trennung zwischen Befehls und Datenbus existiert, jedoch sowohl Befehle und Daten im gleichen Speicher (Flash) liegen und
somit der Adressraum dementsprechend linear programmiert werden kann.
Hier spricht man oft von eine Adeptive Harvard Architektur, da es zwar verschiedene Busse für Daten und Befehle gibt, jedoch keine strikte Trennung zwischen Daten und Befehlsadressraum gegeben ist.
Zudem ist hier kein getrennter physikalischer Speicher für Daten und Befehle vorhanden.
Dabei sichert man sich den Vorteil der Harvard-Architektur, dass gleichzetiges Laden von Befehlen und Daten für bessere Performance möglich ist, jedoch
verliert man den Nachteil durch den gemeinsamen Adressbereich bzw. Speicherbereich wie in Neumann, dass der Programmcode manipuliert werden kann.
Dies ist insbesondere bei der Schwachstelle Buffer Overflow bzw. Return Orientated Programming von Bedeutung.
% noch erwähnen, dass ARM CORTEX M3 Memory Protection besitzt
Des Weiteren besitzen die meisten STM32, insbesondere der in der Übung verwendete STM32F103C8T6, eine \ac{mpu}.
Diese ermöglicht es, ein eingebettetes System robuster und sicher zu machen, indem beispielsweise der SRAM bzw. Bereiche vom SRAM als nicht-ausführbar definiert werden können.
% verbieten, dass User applikation von korrupten dataen verwendet von kritischen tasks wie os kernel
% Memmory access attributes ändern

%%%% SPEICHERZUGRIFF
% Der Speicherzugriff funktioniert wie auf folgender Abilldung dargestellt:\\
% \begin{figure}[ht!]
%   \begin{center}
%     \includegraphics[scale=0.28]{figures/speicherzugriff_aktiv.png}
%     \caption{Speicherzugriff}
%     \label{Abbildung 1: Speicherzugriff}
%   \end{center}
% \end{figure}
% Im Speicherzugriffsregister (Memory address register MAR) wird die Adresse angelegt, auf die im Speicher zugegriffen werden soll.
% Anschließen wird im Adress Decode die Adresse entschlüsselt/übersetzt und die jewelige Addresslinie wird aktiv geschalten.
% Daraufhin wird die aktiv geschaltene Linie, mit 8 indiviuellen Speicherzellen (jeweils 1 Bit), also insgesamt 1 Byte in
% das Speicherregister geladen (Memory data register MDR).
%%%%

%%%% LITTLE ENDIAN
Außerdem ist hier zu erwähnen, dass die STM32 Mikrocontroller-Familie auf Little Endian setzt, d.h. das niederwertigste Byte befindet sich an der niedrigsten Adresse.
% Hier wird beispielsweise ein integer ivar=0x01234567 folgendermaßen abgespeichert:
% \begin{figure}[ht!]
%     \begin{center}
%       \includegraphics[scale=0.28]{figures/speicher_littleEndian.png}
%       \caption{Little Endian}
%       \label{Abbildung 1: Little Endian}
%     \end{center}
% \end{figure}
Die Abspeicherung in Little Endian spielt insbesondere für die Schwachstelle Buffer Overflow eine wichtige Rolle, da beim Auslesen des
Speichers dies zu berücksichtigen ist.


% Kein OS, das irgendwelche Sdchutzmechanismen bieten würde!!!!


% ============================================================================== Kapitel 3: Schwachstellen =======================================================================================================
\section{Schwachstellen}
%%%%% MEMCMP TIMING ATTACKE
\subsection{memcmp Timing Attacke für Bruteforcing}
\subsubsection{Beschreibung}
Die memcmp Timing Attacke ist ein typischer Seitenkanal-Angriff. Diese Art von Angriffen basieren auf Informationen, die von der konkreten Implementierung eines Systems abhängen.
Bei der memcpm Timing Attacke basiert dies auf dem Wissen über die Softwareimplementierung eines Vergleichs von Speicherbereichen.
%welche konkret in diesem Fall auf die Softwareimplementierung eines Vergleichs von Speicherbereichen.
Denn im Fall, dass eine Speichervegleichsfunktion so implementiert ist, dass beim ersten nicht übereinstimmende vergleichenenen Zeichen von der Funktion 'false' zurückgegeben wird,
benötigt der Vergleich unterschiedlich lange, je nach Anzahl richtiger Buchstaben einer Zeichenkette.
Hier wird konkret der Aspekt der Zeit ausgenutzt, denn die Dauer der Funktion hängt von den zu vergleichenden Speicherbereichen ab.
Je länger die Funktion benötigt, desto mehr Buchstaben waren beim entsprechenden Vergleich richtig.
Diese Information der Dauer einer Funktion je nach Vergleich kann man nun ausnutzen, um Bruteforcing bei Passworteingaben deutlich zu optimieren.
Bei 'normalen' Bruteforcing müssen alle Kombinationen durchrpobiert werden, d.h.
bei einem Passwort der Länge 6 müssen bis zu $|A|*|A|*|A|*|A|*|A|*|A| = |A|^6$ Möglichkeiten durchprobiert werden.
$|A|$ ist die Mächtigkeit der möglichen Eingabezeichen.
Dahingegen kann bei einer memcmp Timing Attacke Stelle für Stelle durchprobiert werden, und die Auswahl für die jeweilige Stelle, die am längsten benötigt hat,
wird als 'richtig' übernommen, denn dann hat die Vegleichsfunktion für die jeweilige Stelle einen erfolgreichen Vergleich durchgeführt.
Dies führt dazu, dass die nächste Stelle überprüft wird, was bedeutet, dass die Funktion dafür mehr Zeit braucht.
Insgesamt führt die memcmp Timing Attacke also zu einer erheblichen Verbesserung, indem beim Fall der Passwortlänge von 6
nur bis zu $ |A|+|A|+|A|+|A|+|A|+|A| = 6 * |A| $ Möglichkeiten durchprobiert werden müssen.

\textit{Anmerkung} \mbox{} \\
In der Realität liegt solch ein Vergleich im Bereich von Nanosekunden, da nur wenige CLock Cycles für den Vergleich benötigt werden.
Dies bedeutet, dass der Delay über ein USB Kabel deutlich größer ist (im Millesekunden Breich) als die Dauer des Vergleichs.
Aus diesem Grund werden für solche memcmp Timing Attacken Oszilloskope oder Logic Analyzers benötigt, um den Zeitunterschied
für den Vergleich am Embedded System zu messen.

\subsubsection{Beispiel}
In diesem Abschnitt wird ein repräsentatives Beispiel für oben genannte Schwachstelle dargestellt.
Der Einfachkeit halber wird ein PIN Vergleich der begrenzten Länge 4 durchgeführt, wobei das Alphabet 0-9 ist, d.h. eine Mächtigkeit von $|A| = 10$ besitzt.
%Dies gilt ohne Beschränkung der Allgemeinheit und kann beliebig in der Länge sowie der Mächtigkeit des Alphabets verändert werden.
Zudem wird die Annahme getroffen, dass der Pin Vergleich erst nach vollständiger Pineingabe erfolgt. Dabei
wird folgender Code Ausschnitt für die Überprüfung des PINs verwendet.
\begin{minted}[linenos]{c}
bool pin_correct(char *input){
  char *correct_pin = "1337";
  for (int i = 0; i < 4; i++){
    if (input[i] != correct_pin[i]){
      return false;
    }
  }
  return true;
}
\end{minted}

Für reines Raten, d.h. Bruteforcing ohne weitere Kenntnisse, sind eine gesamte Anzahl von $ 10*10*10*10 = 10^4 $ Kombinationen möglich.
Um die Anzahl der Kombinationen deutlich zu reduzieren kann man den Vorteil des Wissens über die obige Funktion nutzen und damit
die memcmp Timing Attacke verwenden.
Denn obiger Code Ausschnitt gibt beim ersten nicht korrekten Zeichen 'false' zurück, weshalb die die Ausführungsdauer der
Funktion von der Anzahl der richtig eingegebenen Pin Stellen abhängt.
Dafür geht man Stelle für Stelle durch und überprüft angefangen bei der ersten Stelle für jede mögliche Eingabe von 0-9, welche die längste Zeit benötigt.
Denn wenn die Stelle richtig ist, war der Vergleich richtig und die Funktion wird die nächste Stelle überprüfen, was mit einer längeren Dauer für die Funktion
einhergeht.
Konkret für die erste Stelle werden also alle Möglichkeiten durchgetestet von \textit{0000, 1000, 2000 bis 9000}, wobei für jeder dieser Eingaben
eine Zeitmessung durchgeführt wird.
Folgende zwei Abbildungen stellen für die erste Eingabestelle dar, wie sich die Vergleichszeit im
korrekten Fall ($t_correct$) zum Fehlerfall ($t_bad$) unterscheidet.
Da der korrekte Pin 1337 ist, wird für die Eingabe 1000 die Vergleichszeit länger dauern, wie in $t_correct$ dargestellt.
Für alle anderen Möglichkeiten wird die linke Abbildung mit $t_bad$ zutreffen.
%Für $t_bad$ kann man als Beispieleingabe \textit{0000, 2000, 3000, ..., 9000} verwenden, während
%der korrekte Fall $t_correct$ die Eingabe  \textit{1000} zutrifft.
Diese Angriff wird für jede Möglichkeit der nächsten Stelle bis zur letzten Stelle druchgeführt ausgehend vor der korrekten Eingabe der jeweils vorherigen Stellen.
Bei der letzten Stelle ist die Zeitmessung überflüssig, denn im korrekten Fall hat man das System entsperrt.
Der Vorteil dieser Methode ist, dass die PIN Stellen sequentiell ausgehend vom Wissen über die Position richtig erraten werden.
Damit erreicht man, dass die maximale Anzahl an Kombinatione maximal $10+10+10+10 = 4*10 = 40 $ beträgt.
Das bedeutet, dass die Möglichkeiten bei der memcmp Timing Attack für Bruteforce gegenüber reinem Bruteforce nur noch $\frac{40}{1000} = \frac{4}{100} = 4\% $
aller Möglichkeiten betragen.

\subsubsection{Prävention/Schutzmaßnahmen}
Für obige Funktion gibt es eine Vielzahl von Schutzmaßnahmen, die im Wesentlichen solche Angriffe deutlich erschweren, aber nicht 100\%ig verhindern.
Bei der Annahme, dass das Passwort in Klartext überprüft wird und nicht als gehashter Wert, werden insgesamt 4 Schutzmaßnahmen vorgestellt.
Die erste Schutzmaßnahme zielt auf eine korrelationslose bzw. konstante Zeit bei der Überprüfung ab. Dies wird erreicht, indem unabhängig
von einer falschen Stelle immer alle Stellen überprüft werden und nachfolgend erst das Ergebnis des Vergleichs zurückgegeben wird.
Hierbei wäre für oben dargestellten Code eine wesentliche Änderung nötig, nämlich die Verwendung ein boolschen Variable,
die defaultmäßig true ist und bei einem fehlerhaften Vergleich auf false gesetzt wird. Dabei ist zu beachten, dass
alle Stellen überprüft werden und erst am Ende das Ergebnis des Vergleichs zurückgegeben wird.
\begin{minted}[linenos]{c}
  bool pin_correct(char *input){
    char *correct_pin = "1337";
    bool test = true;
    for (int i = 0; i < 4; i++){
      if (input[i] != correct_pin[i]){
        test = false;
      }
    }
    return test;
  }
\end{minted}

Eine ähnliche Schutzmaßnahmen, die zwar nicht auf konstante Zeit setzt, sondern auf Randomisierung von Zeit, kann durch hinzufügen von
randomisierten sleeps implementiert werden. Dies erschwert die Korrelation von gemessener Zeit und korrekter bzw. fehlerhafter Eingabe.
% zufällige Startzugriffe
% decoy operations

% Korrelationslose/Konstante Zeiten überall (Siehe letzte Folien):
% • Keine Messbaren Funktionsaufrufe
% Zufällige Startzugriffe (Siehe letzte Folien):
% • Angreifer kann schwerer Reihenfolge nachvollziehen
% Timing Randomization:
% • Bsp. sleep(random.randint(0,9))
% • Schwer Messbare Informationen

% Decoy Operations:
% • Algorithmen führen zufällig Berechnungen durch und verwenden Ergebnis nicht
% • Bsp. Memcmp vergleicht einige Werte mehrmals
% • Verfälschen der Seitenkanalinformationen

%%%%% FORMAT STRING VULNERABILITY
\subsection{Format String Vulnerabilty}
\subsubsection{Beschreibung}
Eine Format String Vulnerabilty tritt auf, wenn eine Benutzereingabe als Befehl interpretiert wird.
Weitergeführt kann ein Angreifer dies ausnutzen, um Code auszuführen, den Stack auszulesen oder gezielt das Programm durch einen Segmentation Fault zum Absturz bringen.
Diese Schwachstelle kann man beipsielsweise in printf, fprintf und weiteren print Funktionen ausnutzen.
Das erste Argument einer printf Funktion ist der sogenannte Format String und die im Format String enthaltenen weiteren Parameter, die mit \% beginnen, wie \%s, \%d, \%x und weitere, werden durch nachfolgende
Argumente ersetzt. Die nachfolgende Abbildung verdeutlicht dies, wobei \textit{name} ein string und \textit{age} eine integer Variable ist, die in den entsprechenden
Paramtern \%s und \%d als Argumente ersetzt werden.
% Parameter im Format String beginnen mit %
\begin{figure}[ht!]
  \begin{center}
    \includegraphics[scale=0.28]{figures/format_string_vulnerability_format_string.png}
    \caption{printf - Format String}
    \label{Abbildung 1: printf - Format String}
  \end{center}
\end{figure}

Falls die printf - Funktion unsicher programmiert ist, wie in folgenden Code-Ausschnitt zu sehen,
wird diese Funktion ohne explizite Parameter aufgerufen, weshalb die Werte von den Registern bzw. weiterführend vom Stack ausgelesen und als Hexadezimal zurückgegeben werden.
\begin{minted}{c}
int main(){
  char *input;
  scanf("Enter any input", input);  // Input vom User z.B.: %x%x%x%x
  printf(input);
}
\end{minted}
Durch das Auslesen von Registern, Stack und Speicher kann ein Angreifer wertvolle Informationen über das laufende Progamm gewinnen.
Dazu können beipsielsweise Passwörter zählen, die im Speicher abgespeichtert.


Des Weiteren ist es möglich, wie anfangs erwähnt, eigenen eingegebenen Code auszuführen. Dabei ist oft das Ziel,
ein Shell zu öffnen, auf der weitere Aktionen ausgeführt werden können.
Hierbei muss man erst den Shell start in Assembly suchen. Mit der Format String Vulnerabilty muss man darauffolgend mit \%x die return Adresse
der jeweiligen print Funktion herausfinden. Nachfolgend kann die Schwachstelle ausnutzen, indem man im Input die Adresse der return Adresse von printf schreibt
und daraufhin \%n ausnutzt um eben an diese Adresse mit der Addresse zum Ausführen der Shell überschreiben.
%% SHELL ANGRIFFSPLAN, NOCHMAL MIT DAWUTZ DRÜBER REDEN; VERSTEHEN,.....
% Anmkerung: Für C Programmierer ist derFehler offensichtlich und wird i.d.R. durch richtiges Programmieren kommplett ausgehebelt,
% jedoch kann es sein dass dieser printf vulnerability noch in anderen aufgerufenen Funktione wie syslog oder irgnedwelchen libs enthalten ist,
% deswegen ist der Fehler nicht so trivial wie er auf dem ersten Blick erscheitn.

\subsubsection{Beispiel}
Folgendes Beispiel konzentriert sich auf die beispielshafte Anwendung der Format String Vulnerabilty in Bezug auf das Auslesen von Speicher.
%Konkret soll hier der RAM ausgelesen werden, in welchen sich das Passwort nach erstmaligen Vergleich geladen wurde.
Der folgende Code zeigt ein Beispielprogramm, dass eine printf Implementierung mit oben beschriebener Schwachstelle aufweist.
\begin{minted}[linenos]{c}
int main(){
  char* correct_password = "f0rm4tS7r!ng";
  char* username;
  int age;
  // User Input
  scanf("Hello, please first enter your age: ", &age);
  scanf("Enter your username: ", username);
  // For taking advantage of this vulnerability: 1. enter a number for which adress to read, 2. enter on the correct position %s to interpret the entered number in 1. as pointer
  // Output
  printf("Your age is: %d", age);
  printf("Welcome ");
  printf(username); // FORMAT STRING Vulnerability
}
\end{minted}
Hierbei wird der Nutzer nach zwei Eingaben gefragt, nämlich dem Alter und dem gewünschten Benutzernamen.
Letztere Eingabe weist die entsprechende Format String Schwachstelle auf.
Hierbei kann der Nutzer bzw. der Angreifer dies ausnutzen, indem er als Alter eine beliebige Zahl eingibt, die als Adresse für die auslzusende Speicherzelle dient.
In der zweiten Eingabe, der Benutzername eingabe, kann man nun mit enstprechend vielen \%d und dann einem \%s, welches sich genau an der Position des
vorher gegebenen Alters eingibt. Beispielsweise kann die Eingabe dann wie folgt aussehen: \textit{\%d\%d\%s}.
Das eingegebene Alter bzw. die Adresse der Speicherstelle, die ausgelesen werden soll, wird mit \%s als Pointer interpretiert und ausgegeben.
Hiermit kann man beispielsweise nun den RAM, den Flash oder andere Speicherbereiche auslesen.

\subsubsection{Prävention/Schutzmaßnahmen}
Für die Format String Vulnerabilty existiert eine einfache sehr effektive Schutzmaßnahme, nämlich
das sichere Programmieren, indem man die Paramter \%s, \%d, ... korrekt benutzt.
Weitere Schutzmaßnahmen in der Software könnten zudem noch sein, die Eingabe des Nutzers zu überprüfen, und
derartige möglicherweise schädliche Eingaben nicht zuzulassen.

%%%%% BUFFER OVERFLOW (ROP)
\subsection{Buffer Overflow (ROP)}
\subsubsection{Beschreibung}


\subsubsection{Beispiel}
% sieh Beispiel in Übung, Skizze machen

\subsubsection{Prävention/Schutzmaßnahmen}
% Data execution Prevention (Memory protection in vorstellung wichtiger rahmbedigungen einfügen)
% Einige Microcontroller (e.g. STM32F303) besitzen eine Memory Protection
% Unit (MPU) mit speziellen Einstellunge

% 1. Data execution prevention (MPU=Memory Protection Unit)
% 2. Protection Rings
% 3. Address Space Layout Randomization (ASLR)
% 4. Stack Canaries
% 5. Watchdogs


% ============================================================================== Kapitel 4: Besprechung der möglichen Skalierbarkeit ==============================================================================
\newpage
\section{Besprechung der möglichen Skalierbarkeit}



% ============================================================================== APPENDIX =========================================================================================================================
\begin{appendix}
\newpage
\listoffigures

\cleardoublepage
\newpage
\begin{thebibliography}{99}
\bibitem{Nemo} Dr. Nemo: \textit{Submarines through the ages}, Atlantis, 1876.
% DataSheeet von STM32F103C8: file:///C:/Users/danie/Downloads/stm32f103c8.pdf
% McKinsey Studie ECU (für einleitung) https://www.mckinsey.com/~/media/mckinsey/industries/automotive%20and%20assembly/our%20insights/mapping%20the%20automotive%20software%20and%20electronics%20landscape%20through%202030/automotive-software-and-electronics-2030-final.pdf
% Colin O'Flynn and Jasper van Woudenberg: The Hardware Hacking Handbook
% MPU:  https://www.st.com/resource/en/application_note/dm00272912-managing-memory-protection-unit-in-stm32-mcus-stmicroelectronics.pdf
% memory model: https://www.st.com/resource/en/application_note/dm00272912-managing-memory-protection-unit-in-stm32-mcus-stmicroelectronics.pdf
\end{thebibliography}

\cleardoublepage
\makedeclaration
\end{appendix}

\end{document}
